# Семинар: RAII и умные указатели (C++)

## Цели

* Понять принцип RAII и его связь с временем жизни объектов.
* Научиться выбирать подходящий умный указатель под задачу.
* Разобраться во всех стандартных видах умных указателей и типовых паттернах использования.

## Что будем обсуждать

* Семантика перемещения: lvalue/rvalue, move‑ctor/move‑assign, автоматическое перемещение, `std::move`.
* RAII: идея и привязка ресурса к объекту.
* Умные указатели: зачем они нужны.
* Виды и фабрики: `unique_ptr`, `shared_ptr`, `weak_ptr`, `make_unique`, `make_shared`.
* Паттерны выбора владения и частые ошибки.
* Короткая шпаргалка.

---

## 1. Семантика перемещения

### 1.1 lvalue / rvalue (кратко)

* **lvalue** — выражение с именем/адресом: переменные, `*p`, `obj.field`, `arr[i]`, `++i`.
* **prvalue** — временное значение: литералы, `i + j`, `T{...}`, результат функции, возвращающей по значению.
* **xvalue** — «выдыхающееся» значение (из него можно перемещать): `std::move(x)`, `static_cast<T&&>(x)`, возвращаемое `T&&`.
* Ссылки: `T&` привязывается к lvalue; `T&&` — к rvalue/xvalue.

```cpp
void f(std::string&);      // для lvalue
void f(std::string&&);     // для rvalue/xvalue
std::string s = "hi";
f(s);                      // lvalue
f(std::move(s));           // xvalue
```

### 1.2 Конструктор и оператор перемещения

* **Конструктор перемещения:** `T(T&&) noexcept` — переносит ресурсы в новый объект, источник остаётся валидным, но «пустым».
* **Оператор присваивания перемещением:** `T& operator=(T&&) noexcept` — освобождает свои ресурсы и забирает у правой части.
* Если тип управляет ресурсом, продумайте «правило пяти»; где возможно — используйте `= default`.

```cpp
class B{
public:
  B(B&&) noexcept = default;
  B& operator=(B&&) noexcept = default;
};
```

### 1.3 Когда перемещение срабатывает автоматически

* Возврат по значению: если возможна оптимизация **NRVO/RVO**, объект строится сразу на месте назначения; иначе выполняется **перемещение**.
* Инициализация из временного: `T x = T(...);`.
* Вставки/реаллокации в STL‑контейнерах предпочитают move, если он `noexcept`.

```cpp
class T{};
T make(){ T x; return x; }     // NRVO/RVO, иначе move
T make2(){ return T{}; }       // RVO
```

### 1.4 Явно перемещаем — `std::move`

* `std::move(x)` — это приведение к rvalue; само по себе ничего не переносит.
* Используйте, когда исходный объект не нужен в прежнем состоянии.

```cpp
std::string a = "hello";
std::string b = std::move(a);   // a остаётся валидной, но пустой
std::vector<std::string> v;
v.push_back(std::move(b));
```

---

## 2. Что такое RAII

**RAII (Resource Acquisition Is Initialization)** — ресурс захватывается в конструкторе и освобождается в деструкторе. Освобождение гарантируется при выходе из области видимости, в том числе при исключениях.

Примеры из стандартной библиотеки: `std::string`, `std::vector`, `std::unique_ptr`, `std::shared_ptr`, `std::lock_guard`/`std::scoped_lock`.

**Пример (RAII с мьютексом):**

```cpp
#include <mutex>
class Guarded {
public:
    void add(int x) {
        std::lock_guard<std::mutex> lk(m_); // захват в конструкторе
        sum_ += x;                           // освобождение в деструкторе lk
    }
private:
    std::mutex m_;
    int sum_{};
};
```

---

## 3. Зачем нужны умные указатели

Проблемы «сырых» указателей: утечки, двойное освобождение, путаница с владением, исключения между `new` и `delete`.

Преимущества умных указателей:

* Явная семантика владения.
* Автоматическое освобождение.
* Меньше ручного кода и ошибок.
* Естественная поддержка перемещения/копирования по правилам конкретного указателя.

**Было → Стало:**

```cpp
// Было (хрупко)
class Widget { /* ... */ };
void foo(){
    Widget* p = new Widget();
    // ... много логики
    delete p; // легко забыть при раннем выходе
}

// Стало (RAII)
void foo(){
    auto p = std::make_unique<Widget>();
    // ...
} // p освобождает ресурс автоматически
```

---

## 4. Виды умных указателей и фабрики

* `std::unique_ptr<T>` — единоличное владение (перемещаемый, **некопируемый**).
* `std::shared_ptr<T>` — разделяемое владение (подсчёт ссылок).
* `std::weak_ptr<T>` — наблюдение без владения (для разрыва циклов и проверки жизненности через `lock()`).

Фабрики:

* `std::make_unique<T>(...)` — рекомендовано: короче/безопаснее, без `new`, прямой вызов конструктора `T`, отсутствие утечек при исключениях, поддержка массивов через `std::make_unique<T[]>(n)`.
* `std::make_shared<T>(...)` — обычно одна аллокация для объекта и контрольного блока.

**Примеры фабрик:**

```cpp
auto up = std::make_unique<Widget>(42);
auto sp = std::make_shared<Widget>(7);
auto arr = std::make_unique<int[]>(1024); // корректный delete[]
```

---

## 5. Подробно про каждый вид

### 5.1 `std::unique_ptr`

Идея: **единоличное владение**.

**Семантика копирования/перемещения:** `std::unique_ptr` **некопируем** (копирующие операции удалены), но **перемещаем**.

**Можно:**

* Возвращать по значению из функций.
* Перемещать владение: `take(std::move(p))`.
* Хранить в контейнерах: `std::vector<std::unique_ptr<T>>`.
* Создавать массивы: `std::make_unique<T[]>(n)`.

**Нельзя/ошибка:**

* Копировать (`auto b = a;` — ошибка компиляции).
* Создавать два владельца на один «сырый» указатель (`a(p); b(p);`) — UB/двойное удаление.
* Вызывать `delete` вручную на объекте под управлением `unique_ptr`.
* Долго хранить «сырые» указатели из `get()` как долговременные ссылки.
* Передавать по значению без `std::move`.

```cpp
class Widget{ public: explicit Widget(int v):v(v){} int v; };

std::unique_ptr<Widget> make(){ return std::make_unique<Widget>(42); }
void take(std::unique_ptr<Widget> ow){ /* стал владельцем */ }

int main(){
    auto a = make();
    // auto b = a;            // НЕЛЬЗЯ: копирование unique_ptr
    auto b = std::move(a);     // МОЖНО: перемещение; a == nullptr
    std::vector<std::unique_ptr<Widget>> vec;
    vec.push_back(std::move(b));
}
```

---

### 5.2 `std::shared_ptr`

Идея: **разделяемое владение** с подсчётом ссылок.

**Можно:**

* Создавать через `std::make_shared<T>(...)`.
* Копировать для разделения владения.
* Получать наблюдателей `std::weak_ptr` и проверять `lock()`.

**Нельзя/не стоит:**

* Делать кольцевые ссылки `shared_ptr↔shared_ptr` — объект утечёт; разрывайте одной стороной через `weak_ptr`.
* Смешивать разные владельцы на один объект (`unique_ptr` + `shared_ptr`).
* Полагаться на `use_count()` в логике (диагностический, может быть неактуален в многопоточной среде).
* Для массивов чаще выбирайте `std::vector<T>` или `std::unique_ptr<T[]>`.

**Как работает в общих чертах (подсчёт ссылок):**

* Есть **контрольный блок** со счётчиками.
* **Сильный счётчик** (число `shared_ptr`): при нуле — объект удаляется.
* **Слабый счётчик** (число `weak_ptr`): при нуле после удаления объекта — освобождается контрольный блок.
* `weak_ptr::lock()` возвращает `shared_ptr`, только если объект ещё жив.

**Мини‑пример:**

```cpp
class Widget { public: explicit Widget(int v):v(v){} int v; };
auto p1 = std::make_shared<Widget>(1);
auto p2 = p1;                   // разделяемое владение
std::weak_ptr<Widget> w = p1;   // наблюдатель
p1.reset();                     // объект ещё жив (держит p2)
if (auto s = w.lock()) { /* ok */ }
p2.reset();                     // strong==0 → объект удалён
auto s2 = w.lock();             // пусто
```

---

### 5.3 `std::weak_ptr`

Идея: **наблюдение без владения**.

**Можно:**

* Хранить наблюдатель на объект, которым владеют `shared_ptr`.
* Проверять «жив ли объект»: `if (auto p = w.lock()) { /* использовать */ }`.
* Разрывать циклы `shared_ptr`.

**Нельзя/ошибка ожиданий:**

* Разыменовывать напрямую (нужно `lock()`).
* «Продлевать жизнь» объекта одним `weak_ptr` — он не владеет.

```cpp
class A; class B;
class A{ public: std::shared_ptr<B> b; };
class B{ public: std::weak_ptr<A>   a; };

int main(){
    auto a = std::make_shared<A>();
    auto b = std::make_shared<B>();
    a->b = b;    // shared владение b
    b->a = a;    // weak наблюдение на a — цикла владения нет
    if (auto pa = b->a.lock()){ /* объект A ещё жив */ }
}
```

---

## 6. Паттерны выбора владения

* По умолчанию храните **значения** для простых/малых типов.
* **Единоличное владение** → `std::unique_ptr` (особенно для полиморфных/крупных объектов, контейнеров указателей).
* **Разделяемое владение** → `std::shared_ptr` (когда реально нужны многие владельцы).
* **Наблюдение без владения** → `T&`/`T*` (без освобождения) или `std::weak_ptr`.
* *Pass‑by‑value, then move* в реализацию — упрощает API и использует move.
* Делайте move‑операции `noexcept`, чтобы контейнеры могли безопасно выбирать перемещение.

**Мини‑шаблоны API:**

```cpp
class Node; class Bus; class Renderer;

// принимает владение
void set_child(std::unique_ptr<Node> child);

// разделяет владение
void subscribe(std::shared_ptr<Bus> bus);

// наблюдение без владения
void render(const Renderer& r);
```

---

## 7. Частые ошибки и анти‑паттерны

* Смешение владений: хранить `T*` из smart‑указателя и освобождать вручную — UB. Для невладеющего доступа используйте `T&`/`T*`/`std::weak_ptr`.
* Циклы `shared_ptr`↔`shared_ptr`: утечка — разрывайте через `std::weak_ptr`.
* Передача `std::unique_ptr` по значению без `std::move`: копирование запрещено — перемещайте явно.
* `std::shared_ptr` для массивов: используйте лучше `std::vector<T>` или `std::unique_ptr<T[]>`.
* Избыточный `std::shared_ptr`: если есть единый владелец — берите `std::unique_ptr`.
* Долгоживущий `raw` из `get()`: ломает инварианты владения, чревато висячими указателями.

**Мини‑примеры ошибок:**

```cpp
// Два владельца на один raw → двойное удаление (НЕЛЬЗЯ)
Widget* raw = new Widget(1);
std::unique_ptr<Widget> a(raw);
// std::unique_ptr<Widget> b(raw); // UB

// Висячий указатель после reset (НЕЛЬЗЯ)
auto sp = std::make_shared<Widget>(3);
Widget* leaked = sp.get();
sp.reset();
// *leaked; // опасно: объект уже удалён
```

## 8. Шпаргалка

* По умолчанию: `unique_ptr`; нужны многие владельцы — `shared_ptr`; наблюдение — `weak_ptr`/ссылки.
* Создавайте через `make_unique` / `make_shared`.
* В API кодируйте семантику параметрами/возвратами:

  * принимает владение → `unique_ptr<T>` по значению;
  * совместное владение → `shared_ptr<T>` по значению;
  * наблюдение → `T&`/`T*`/`weak_ptr<T>`.
* Контейнеры: храните **значения** или `unique_ptr`.
* Для синхронизации — RAII‑обёртки (`lock_guard`, `scoped_lock`).
