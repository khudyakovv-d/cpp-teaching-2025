# C++ — Наследование: конспект занятия (чистовая версия)

## 1) Виды отношений: is‑a / part‑of / association / dependency

### Наследование (is‑a)

Отношение обобщения «A является B»: подтип можно подставить вместо базового без нарушения контрактов (LSP). Примеры (из жизни): «Кошка — это Животное», «Круг — это Фигура».

```cpp
class Animal {
public:
    virtual ~Animal() = default;
    virtual void sound() const = 0;
};

class Cat : public Animal {
public:
    void sound() const override { /* meow */ }
};
```

### Композиция (жёсткое part‑of)

«Часть‑целое» с владением: целое управляет временем жизни частей. Уничтожение целого уничтожает части. Примеры: «Дом состоит из Комнат», «Телефон состоит из Аккумулятора».

```cpp
#include <vector>
#include <memory>

class Room {};

class House {
private:
    std::vector<Room> rooms;                 // или: std::vector<std::unique_ptr<Room>>
};
```

### Агрегация (мягкое part‑of)

«Часть‑целое» без владения: жизненные циклы **не связаны** (уничтожение целого не трогает часть). Пример: «Команда использует Стадион» (1 к 1, не‑владеющий указатель).

```cpp
class Stadium {};

class Team {
public:
    explicit Team(Stadium* s) : stadium(s) {}

    Stadium* getStadium() const { return stadium; } // non‑owning 1:1
    void setStadium(Stadium* s) { stadium = s; }

private:
    Stadium* stadium; // non‑owning
};
```

### Ассоциация (association)

Структурная связь между объектами (обычно поле‑ссылка/указатель). **Композиция** и **агрегация** — частные случаи ассоциации с разной семантикой владения и временем жизни.

### Зависимость (dependency)

Неструктурная связь «использую и не храню» — краткосрочное использование через параметр/локальную переменную.

```cpp
class Logger { public: void write(std::string_view); };

class Report {
public:
    void generate(Logger& log) { log.write("done"); } // dependency как параметр
};
```

**Быстрый выбор:** нужна подстановка → наследование; владею частью → композиция; храню без владения → агрегация; только параметр → зависимость.

---

## 2) Синтаксис наследования

```cpp
class Base {
public:
    virtual ~Base() = default;

    void f() { /* non‑virtual */ }
    virtual void g() { /* virtual */ }
};

class Derived : public Base { // public = is‑a
public:
    void g() override { /* ... */ }
    void h() { /* ... */ }
};
```

### Пояснения к синтаксису

* Наследование объявляется после двоеточия: `class D : public B`.
* По умолчанию: у `class` — **private** наследование; у `struct` — **public**.
* Несколько базовых классов перечисляются через запятую: `class D : public B1, protected B2` (детали см. §9).
* Порядок конструирования/уничтожения базовых классов соответствует **порядку объявления** в списке наследования (подробнее см. §4).
* Метка `override` ставится в объявлении переопределённого виртуального метода (см. §5). В полиморфной иерархии базовый деструктор должен быть `virtual` (см. §5).

---

## 3) Доступ и вид наследования

* **Изнутри производного** (код класса `Derived`) — независимо от вида наследования:

  * доступны: члены базового `Base` с уровнями `public` и `protected`;
  * недоступны напрямую: `private` базового `Base`.
* **Внешний доступ через `Derived` и приведение:**

  * `public Base`: `public` остаются `public`, `protected` остаются `protected`; неявное приведение к `Base*`/`Base&` **разрешено**.
  * `protected Base`: `public` и `protected` базового становятся `protected` в `Derived`; приведение к `Base*`/`Base&` извне **запрещено** (доступно внутри иерархии/друзьям).
  * `private Base`: всё из `public`/`protected` базового становится `private` в `Derived`; приведение к `Base*`/`Base&` извне **запрещено**.

---

## 4) Конструирование и уничтожение при наследовании

**Порядок конструирования (top‑down):**

1. **Базовые классы** — в порядке объявления в списке наследования производного;
2. **Поля‑члены** — в порядке объявления в классе (не в порядке списка инициализации);
3. Выполняется **тело конструктора**.

**Порядок уничтожения — в обратном порядке:** сначала тело деструктора производного, затем его поля (в обратном порядке объявления), затем базовые классы.

**Выбор конструкторов:** если конструктор базового/поля не указан в списке инициализации — вызывается его **конструктор по умолчанию** (если есть).

**Исключения:** если при конструировании под‑объекта выброшено исключение, все уже сконструированные под‑объекты будут корректно уничтожены в обратном порядке, затем исключение продолжит распространение.

**Мини‑пример (порядок вызовов):**

```cpp
#include <iostream>
class A {
public:
    A()  { std::cout << "A()" << std::endl; }
    ~A() { std::cout << "~A()" << std::endl; }
};
class B : public A {
public:
    B()  { std::cout << "B()" << std::endl; }
    ~B() { std::cout << "~B()" << std::endl; }
};
class C {
public:
    C()  { std::cout << "C()" << std::endl; }
    ~C() { std::cout << "~C()" << std::endl; }
};
class D : public B {
public:
    D()  { std::cout << "D()" << std::endl; }
    ~D() { std::cout << "~D()" << std::endl; }
private:
    C c; // member
};
int main() { D d; }
```

**Ожидаемый вывод:**

```
A()
B()
C()
D()
~D()
~C()
~B()
~A()
```

---

## 5) Виртуальные / чисто виртуальные функции

```cpp
class Base {
public:
    virtual ~Base() = default;
    virtual void g() = 0; // pure -> abstract class
};

class Derived : public Base {
public:
    void g() override { /* ... */ }
    void f() { /* ... */ }
};

Base* p = new Derived{};
p->g ();
delete p; // Base dtor must be virtual
```

**Определения и правила:**

* **Виртуальная функция** — метод, реализация которого выбирается по **динамическому типу** объекта при вызове через базовую ссылку/указатель (динамическая диспетчеризация через vtable). Нужна для **полиморфизма**: писать код на `Base&/Base*`, получая поведение `Derived`.
* **Обычная (невиртуальная)** — разрешается по **статическому типу** выражения; при обращении через базовый интерфейс всегда вызывается версия из базового класса.
* **Чисто виртуальная** (`= 0`) — объявляет интерфейс без реализации в базе и делает класс **абстрактным**; конкретные потомки обязаны предоставить реализацию.

**Переопределение в наследниках:**

* Сигнатура должна совпадать по имени/параметрам и квалификаторам (`const`, `&`, `noexcept`); допускается **ковариантный возврат** (указатель/ссылка на производный тип).
* Помечайте переопределения словом `override`; запретите дальнейшее переопределение с помощью `final`.
* **Аргументы по умолчанию** у виртуальных методов выбираются **статически** — по статическому типу выражения.

```cpp
class Base {
public:
    virtual ~Base() = default;
    virtual Base* clone() const = 0;            // чисто виртуальная
    virtual void draw(int scale = 1) const;     // виртуальная с аргументом по умолчанию
};

class Derived : public Base {
public:
    Derived* clone() const override { return new Derived(*this); } // ковариантный возврат
    void draw(int scale) const override { /* ... */ }
};
```

**Практика и подводные камни:**

* Избегайте **object slicing** — не храните полиморфные объекты по значению; используйте ссылки/указатели (`std::unique_ptr<Base>`).
* В полиморфной иерархии деструктор базового класса должен быть **virtual**.

---

### Почему деструктор базового класса должен быть `virtual`

Если удалять объект производного класса через указатель/ссылку на базовый, должен вызываться **деструктор динамического типа**. Без `virtual` у базового — будет вызван только `~Base()`, а `~Derived()` **не вызовется** → утечка ресурсов и **неопределённое поведение**.

**Плохо (без `virtual`):**

```cpp
#include <iostream>
class Base {
public:
    ~Base() { std::cout << "~Base" << std::endl; } // НЕ virtual
    virtual void g() = 0;
};
class Derived : public Base {
public:
    Derived() : data(new int[10]) {}
    ~Derived() { delete[] data; std::cout << "~Derived" << std::endl; }
    void g() override {}
private:
    int* data{};
};
int main() {
    Base* p = new Derived{};
    delete p; // UB: вызовится только ~Base, ~Derived пропустится
}
```

**Правильно (с `virtual`):**

```cpp
#include <iostream>
class Base {
public:
    virtual ~Base() { std::cout << "~Base" << std::endl; }
    virtual void g() = 0;
};
class Derived : public Base {
public:
    Derived() : data(new int[10]) {}
    ~Derived() override { delete[] data; std::cout << "~Derived" << std::endl; }
    void g() override {}
private:
    int* data{};
};
int main() {
    Base* p = new Derived{};
    delete p; // корректно: ~Derived, затем ~Base
}
```

**Примечание.** Если класс не предназначен для полиморфного удаления, можно запретить `delete` через базовый тип, сделав деструктор **protected** (и не `virtual`). Это явный контракт: удалять объекты должен владелец динамического типа.

## 6) vtable и механизм разрешения виртуального вызова (кратко)

* Полиморфный объект получает скрытое поле‑указатель **`vptr`** на таблицу виртуальных функций (**`vtable`**) только если в его классе есть хотя бы одна виртуальная функция/деструктор.
* **`vtable`** — это массив указателей (и служебных записей), через который при вызове через базовый интерфейс выполняется **динамическая диспетчеризация**: выбор реализации по **динамическому типу**.
* Вызов `p->g()` (где `p` имеет статический тип `Base*`) компилятор превращает в: загрузка `p->vptr`, чтение нужной ячейки `vtable` для `g`, переход по адресу реализации.
* При множественном наследовании у объекта может быть **несколько `vptr`** (по одному на каждую «часть» базового), механизмы RTTI (`dynamic_cast`, `typeid`) используют те же служебные структуры.

**Важно:** точная структура `vtable` не стандартизована; ниже — типичная (упрощённая) схема для Itanium‑подобных ABI у GCC/Clang.

### Пример vtable для наших классов `Base` / `Derived`

Код (см. §2):

```cpp
class Base {
public:
    virtual ~Base() = default;
    virtual void g();
    virtual void h();
};
class Derived : public Base {
public:
    void g() override;
    void h() override;
};
```

**vtable(Base)** — схематично:

| Индекс | Запись в vtable | Комментарий |
| -----: | --------------- | ----------- |
|      1 | &typeinfo(Base) | RTTI        |
|      2 | &Base::~Base    | деструктор  |
|      4 | &Base::g        | слот `g`    |
|      5 | &Base::h        | слот `h`    |

**vtable(Derived)** — схематично:

| Индекс | Запись в vtable    | Комментарий                   |
| -----: | ------------------ | ----------------------------- |
|      1 | &typeinfo(Derived) | RTTI                          |
|      2 | &Derived::~Derived | деструктор динамического типа |
|      4 | &Derived::g        | переопределение `g`           |
|      5 | &Derived::h        | переопределение `h`           |

**Алгоритм разрешения виртуального вызова (шаги):**

1. **Компиляция класса.** Для каждого полиморфного класса компилятор строит layout `vtable`: слоты идут в порядке объявления виртуальных функций в базе; при переопределении класс кладёт в свой слот указатель на реализацию.
2. **Размещение объекта.** В каждом полиморфном под‑объекте хранится скрытый указатель `vptr` на соответствующую `vtable` динамического типа этого под‑объекта.
3. **Фаза вызова.** Для выражения вида `p->f(args)` со статическим типом `Base*`:

   * компилятор вычисляет **индекс слота** для `f` из описания `Base`;
   * во время выполнения берёт `vptr` из под‑объекта `Base` внутри динамического объекта;
   * читает указатель из `vtable[slot]` (это адрес реализации виртуальной функции для динамического типа);
   * делает косвенный вызов по полученному адресу, передавая `this` и аргументы.
4. **Если функция не переопределена** в производном — в слоте остаётся указатель на реализацию базового класса.
5. **Если функция чисто виртуальная** и вызывается без переопределения — попадаем в обработчик "pure virtual call" (обычно аварийное завершение).
6. **Оптимизации.** Если динамический тип известен на этапе компиляции (или можно доказать единственность реализации), компилятор может **де‑виртуализовать** вызов и заинлайнить реализацию.

**Мини‑пример (идея разрешения вызова):**

```cpp
class Base {
public:
    virtual ~Base() = default;
    virtual void g();
    virtual void h();
};
class Derived : public Base {
public:
    void g() override; // попадает в слот g класса Derived
    void h() override; // попадает в слот h класса Derived
};

void call(Base* p) {
    p->g(); // берётся адрес из vtable динамического типа *p и вызывается реализация Derived::g()
}
```