# 0) Поля класса и отличие от структуры в C

**Определение и правила.** *Поля класса* (data members) — это переменные, которые хранят состояние объекта. У каждого объекта свои значения полей. Доступ к полям регулируется спецификаторами доступа (`private/public/protected`), что позволяет скрывать внутреннее устройство и поддерживать инварианты класса.

**Класс vs структура.** В C++ `class` и `struct` равноправны по возможностям (могут иметь поля, методы, конструкторы/деструктор, перегрузки операторов). Главное различие — **доступ по умолчанию**: у `class` — `private`, у `struct` — `public`. В языке C (не C++) структура содержит только данные: нет конструкторов/деструктора, нет методов и контроля доступа; копирование — побайтовое, поэтому инварианты приходится поддерживать дисциплиной кода.

**Абстракция и инкапсуляция.**

* **Абстракция** — это описание того, *что* объект делает, без деталей *как* он устроен. Для `Vector` это операции `size()`, индексирование `operator[]`, сложение `operator+`. Клиенту не важно, хранится ли массив как `int*`, `std::unique_ptr<int[]>` или иным образом.
* **Инкапсуляция** — объединение данных и методов и управление доступом к данным. Поля `arr_` и `size_` скрыты (`private`), а работа с ними идёт через публичные методы. Это помогает удерживать инварианты (например, не допустить отрицательный `size_` или «висячий» указатель).
* Практический эффект: можно менять внутреннее представление (реализацию) без переписывания кода пользователей, пока интерфейс остаётся прежним.

**Код из проекта.**

```cpp
class Vector {
private:
    int * arr_;
    int size_;

public:
    Vector();
    explicit Vector(int size);
    Vector(const Vector &vec);
    ~Vector();
    int &operator[](int i);
    int const &operator[](int i) const;
    Vector &operator=(const Vector &vec);
    int size() const;
    // Оператор сложения как метод класса
    Vector operator+(const Vector &other) const;
};

// Свободная функция сложения двух векторов (часть интерфейса модуля)
Vector operator+(const Vector &vec1, const Vector &vec2);
```

**Что важно заметить.** Поля `arr_` и `size_` — это внутреннее представление (state) класса. Они объявлены `private`, чтобы сохранять инварианты через публичные методы. Интерфейс класса задаёт внешнее поведение (`size()`, `operator[]`, конструкторы/деструктор и т.д.).

**Типичные ошибки.** Делать поля публичными и менять их напрямую; «утечка абстракции» — возвращать наружу сырой указатель на внутренний буфер и позволять его менять; управлять памятью вне методов класса; путать `class`/`struct` в C++ с `struct` в C (в C нет конструкторов/деструктора и контроля доступа).

---

# 1) Память в C и C++; выражение `new`

**Стек vs куча: ключевые различия.**

* **Где и как выделяется.** *Стек* — область для локальных объектов; выделение/освобождение происходит автоматически (сгенерированный код двигает указатель стека). *Куча* — общий пул; выделение через аллокатор (`new`/`delete`).
* **Время жизни.** На *стеке* — до конца области видимости (или при раскрутке стека из‑за исключения). В *куче* — пока явно не вызван `delete`/`delete[]`.
* **Стоимость.** Стек — очень дёшево (почти O(1)). Куча — дороже: метаданные, возможная фрагментация.
* **Размер.** Стек ограничен (обычно мегабайты на поток); глубокая рекурсия/большие объёмы могут переполнить стек. Куча масштабируется в пределах, разрешённых ОС.
* **Потоки.** У каждого потока свой стек; куча общая для процесса и обслуживается аллокатором.
* **Адреса и валидность.** Адреса стековых объектов недействительны после выхода из области видимости; адреса из кучи действительны до `delete`.
* **Когда что выбирать.** Небольшие и короткоживущие данные — на стеке. Переменный объём, разделяемые данные или долгий срок жизни — в куче.

**Выделение памяти в C.** В C используют `malloc/calloc/realloc` и `free`. Эти функции управляют **сырым** блоком памяти и **не** вызывают конструкторы/деструкторы (их в C нет). При ошибке `malloc/calloc/realloc` возвращают `NULL` — требуется явная проверка и ручная инициализация данных.

**Выражение `new`/`delete` в C++.** В C++ **выражение** `new` объединяет выделение памяти и создание объекта(ов) (для массивов — `new[]`). Освобождение и разрушение выполняют `delete`/`delete[]`. Пары должны совпадать: `new` ↔ `delete`, `new[]` ↔ `delete[]`; смешивать с `malloc/free` нельзя. При нехватке памяти `new` бросает `std::bad_alloc`.

**Код из проекта.**

```cpp
Vector::Vector(int size) {
    this->arr_ = new int[size]{};
    this->size_ = size;
    std::cout << "Create vector " << this << " with size " << size << "
";
}
```

```cpp
Vector::Vector() {
    this->arr_ = nullptr;
    this->size_ = 0;
    std::cout << "Create vector " << this << "
";
}
```

**Что важно заметить.** В конструкторе размера используется `new[]` и запись `{}` — это нулевая инициализация: все элементы станут равны 0. В конструкторе по умолчанию память не выделяем: пустой вектор — это `arr_ == nullptr` и `size_ == 0`.

**Как это связано с `Vector`.** Сам объект `Vector` может лежать на стеке или в куче (зависит от вызывающего кода), но его внутренний буфер `arr_` **всегда** выделяется в куче через `new[]`. Поэтому деструктор обязан вызывать `delete[]` — вне зависимости от места хранения самого объекта.

**Типичные ошибки.** Смешать `new[]/delete[]` с `malloc/free`; забыть `delete[]`; создать пустой вектор и затем обращаться по индексу `v[0]`; хранить указатель на стековый объект, который уже вышел из области видимости.

---

# 2) Конструктор и деструктор: жизненный цикл и инварианты

Конструктор и деструктор: жизненный цикл и инварианты
**Определение и правила.** *Инварианты класса* — это внутренние правила про поля объекта, которые должны быть верны после работы конструкторов и по завершении каждого публичного метода. Конструкторы устанавливают корректное начальное состояние. Деструктор освобождает ресурс ровно один раз.

**Код из проекта.**

```cpp
Vector::Vector() {
    this->arr_ = nullptr;
    this->size_ = 0;
    std::cout << "Create vector " << this << "\n";
}
```

```cpp
Vector::Vector(int size) {
    this->arr_ = new int[size]{};
    this->size_ = size;
    std::cout << "Create vector " << this << " with size " << size << "\n";
}
```

```cpp
Vector::~Vector() {
    delete[] this->arr_;
    std::cout << "Delete vector " << this << "\n";
}
```

**Что важно заметить.** Инварианты нашего `Vector`:

* `size_ >= 0`.
* Если `size_ == 0`, то буфера нет: `arr_ == nullptr`.
* Если `size_ > 0`, то `arr_ != nullptr` и указывает на непрерывный массив из `size_` элементов `int`.
* Пара для памяти: `new[]` ↔ `delete[]`.

**Примеры: объект на стеке и на куче.**

```cpp
void demo() {
    // Объект на стеке: разрушится автоматически в конце блока
    Vector a(3);

    // Объект на куче: живёт, пока явно не освободим
    Vector* p = new Vector(5);
    // ... работа с *p ...
    delete p; // явный вызов освобождения

    // Массив на куче: каждый элемент — полноценный Vector
    Vector* arr = new Vector[2]{ Vector(1), Vector(1) };
    // ... работа с arr[0], arr[1] ...
    delete[] arr; // деструктор вызовется для каждого элемента
}
```

**Что произойдёт.** `a` будет уничтожен при выходе из `demo()`. Для `p` деструктор вызовется при `delete p;`. Для `arr` деструкторы вызовутся для всех элементов при `delete[] arr;`.

**Типичные ошибки.** Утечка памяти при забытом `delete[]`; несогласованные поля (например, `size_ > 0`, а `arr_ == nullptr`); доступ к элементам при `size_ == 0`.

**Когда вызывается деструктор.**

* Для объектов **автоматической длительности хранения** (локальные переменные) — при выходе из области видимости (в конце блока/функции) и при раскрутке стека из‑за исключения.
* Для объектов, созданных через **`new`/`new[]`** — при вызове соответствующего **`delete`/`delete[]`**.
* Для **временных объектов** — в конце *полного выражения*, где они были созданы.
* Для **элементов массивов/членов класса** — при разрушении содержащего объекта: элементы разрушаются в обратном порядке конструирования; члены класса — в обратном порядке объявления.
* Для объектов **статической длительности хранения** — при завершении программы (в порядке, обратном инициализации).

---

# 3) Конструктор копирования: глубокая копия

**Определение и правила.** Наш класс владеет динамической памятью, поэтому при копировании нужно делать **глубокую** копию: выделить новый буфер и скопировать элементы. Простое копирование указателя приведёт к двойному освобождению и ошибкам.

**Код из проекта.**

```cpp
Vector::Vector(const Vector &vec) : arr_(new int[vec.size()]), size_(vec.size()) {
    for (int i = 0; i < vec.size(); i++) {
        this->arr_[i] = vec[i];
    }
    std::cout << "Create " << this << " from " << &vec << "
";
}
```

**Что важно заметить.** Сложность по времени — `O(n)`, где `n` — число элементов. Если память выделить не удалось и выброшено исключение, исходный `vec` не меняется.

**Когда вызывается конструктор копирования.**

* При **инициализации** нового объекта из существующего: `Vector b(a);` или `Vector b = a;`.
* При **передаче по значению** в функцию и **возврате по значению** из функции (копирование может быть опущено оптимизациями копирования/перемещения).
* При **захвате по значению** в лямбдах, создании элементов контейнеров из существующих объектов и при **реаллокации** контейнеров, если для типа нет перемещения.

**Типичные ошибки.** Скопировать только указатель; не скопировать `size_` вместе с данными.

---

# 3.5) Указатель vs ссылка в C++

**Определение и правила.**

* **Указатель (`T*`)** хранит адрес. Его можно «переназначать» (указывать на другой объект), он может быть `nullptr`. Разыменование — через `*p`, доступ к адресу — `&x`. Разрешена арифметика указателей (с осторожностью).
* **Ссылка (`T&`)** — это другое имя уже существующего объекта. Её нужно инициализировать сразу, «перепривязать» нельзя, `nullptr` быть не может (хотя возможны «висячие» ссылки на уничтоженные объекты). Используется как обычная переменная — без `*` при чтении/записи.

**Код из проекта.**

```cpp
// Поле-указатель внутри класса
int * arr_;
```

```cpp
// Методы, возвращающие ссылки на элемент
int &Vector::operator[](int i) {
    return this->arr_[i];
}

int const &Vector::operator[](int i) const {
    return this->arr_[i];
}
```

**Что важно заметить.**

* Поле `arr_` — именно **указатель**, потому что в разных местах жизненного цикла мы выделяем/освобождаем буфер и «переназначаем» адрес (`new[]` в конструкторах, новое `new[]` в `operator=`). Ссылка для этой роли не подходит: её нельзя обнулять и перепривязывать.
* `operator[]` возвращает **ссылку** на элемент: это позволяет читать/писать элемент без копирования; в `const`‑версии возвращается `const&`, чтобы запретить изменение.
* Указатель может быть `nullptr` (например, в пустом векторе), ссылка — нет. Поэтому поле‑ссылка в таком классе было бы неудобно и небезопасно.

**Мини‑пример использования.**

```cpp
Vector v(3);
int &r = v[0];   // r — ссылка на первый элемент
int *p = &v[0];  // p — указатель на первый элемент
*r = 42;         // меняем элемент через ссылку
*p = 13;         // меняем элемент через указатель
```

**Типичные ошибки.** Разыменование `nullptr`; «висячая» ссылка/указатель (объект уже уничтожен); возврат ссылки на локальную переменную; выход за границы массива при `operator[]`.

---

# 4) Копирующее присваивание: самоприсваивание и исключения

**Определение и правила.** Присваивание заменяет содержимое уже созданного объекта. Важно обрабатывать случай `a = a;` (самоприсваивание) и думать о том, что будет, если выделение памяти не удастся.

**Код из проекта.**

```cpp
Vector &Vector::operator=(const Vector &vec) {
    if (this == &vec) {
        return *this; // защита от самоприсваивания
    }

    delete[] this->arr_;

    this->size_ = vec.size();
    this->arr_ = new int[vec.size()];

    for (int i = 0; i < vec.size(); i++) {
        this->arr_[i] = vec[i];
    }

    std::cout << "Copy " << &vec << " to " << this << "
";
    return *this;
}
```

**Что важно заметить.** Минимальная защита от самоприсваивания — проверить `if (this == &vec) return *this;`. Более надёжный приём, который часто обсуждают, — **copy-and-swap**: сначала сделать копию, а затем поменять содержимое местами.

**Когда используется копирующее присваивание.**

* При выражениях вида `a = b;`, где **оба объекта уже сконструированы**.
* В составных выражениях `a = b + c;` — присваивание получает временный результат справа.
* В контейнерах и алгоритмах, когда элементы **перезаписывают** существующие значения (например, `std::fill`, `std::vector::assign` для уже выделенных элементов).
* **Не** используется при инициализации параметров/переменных — там работает именно инициализация (в т.ч. копирующая), а не присваивание.

**Типичные ошибки.** Сначала удалить старый буфер, а потом упасть на `new[]` — объект останется «битым»; забыть про самоприсваивание.

---

# 5) `const`‑корректность: `const` у возвращаемого значения и `const`‑методы

**Определение и правила.** Если метод помечен как `... f() const`, он не должен менять состояние объекта. В возвращаемых типах `const` важен у ссылок/указателей (запрещает менять то, на что ссылаемся). Для значений `const` обычно не пишут.

**Код из проекта.**

```cpp
int &Vector::operator[](int i) {
    return this->arr_[i];
}

int const &Vector::operator[](int i) const {
    return this->arr_[i];
}

int Vector::size() const {
    return this->size_;
}
```

**Что важно заметить.** Есть две версии `operator[]`: одна даёт доступ для записи, другая — только для чтения, если объект `const`. Метод `size()` — наблюдатель, поэтому он `const`.

**Как читать объявления `const` (правило справа‑налево).** Начинайте с имени и читайте вправо, затем влево, учитывая `&`, `*` и `const`.

```cpp
int const & r1;       // r1: ссылка на const int
int * const p1;       // p1: const-указатель на int (неизменяемый указатель)
int const * p2;       // p2: указатель на const int (данные только для чтения)
int const * const p3; // p3: const-указатель на const int
int const *& rp;      // rp: ссылка на указатель на const int
```

**Что нельзя делать (примеры):**

* Для `r1` (`int const&`): нельзя `r1 = 5;` (нельзя менять связанный объект); нельзя «перепривязать» ссылку к другому объекту.
* Для `p1` (`int * const`): нельзя `p1 = &x;` и нельзя `p1 = nullptr;` — сам указатель неизменяем. Менять `*p1` можно, если объект не `const`.
* Для `p2` (`int const*`): нельзя `*p2 = 10;` — данные только для чтения. Переназначать указатель можно: `p2 = &x;` допустимо.
* Для `p3` (`int const* const`): нельзя ни переназначать указатель (`p3 = &x;`), ни писать в данные (`*p3 = 10;`).
* Для `rp` (`int const *&`): нельзя перепривязать ссылку к другому **указателю** после инициализации; нельзя писать через неё в данные: `*rp = 10;` — ошибка (данные `const`).

**Важно.** Нельзя снимать константность через `const_cast` и затем писать в объект, который изначально объявлен `const` — это *неопределённое поведение*.

Для методов:

```cpp
int size() const;                  // метод не меняет объект, возвращает по значению
int const& operator[](int) const;  // возвращает const‑ссылку; менять элемент нельзя
```

Заметьте: `const` у возвращаемого по значению типа обычно не нужен (`int const f();` эквивалентно `int f();`).

**Типичные ошибки.** Нет `const`‑версии `operator[]`, из‑за чего нельзя индексировать `const Vector`; возврат «лишнего» `const` по значению.

---

# 6) Операторы сложения: метод класса и свободная функция — различия

**Определение и правила.** Перегрузить оператор `+` можно как метод внутри класса, так и как свободную функцию. Метод класса обычно имеет сигнатуру `Vector operator+(const Vector &other) const;` и вызывается у объекта (`a + b` вызывает `a.operator+(b)`). Свободная функция объявляется вне класса и принимает оба аргумента явно.

**Код как метод класса (пример).**

```cpp
Vector Vector::operator+(const Vector &other) const {
    if (this->size_ != other.size_) {
        throw std::length_error("Vectors must be same size");
    }
    Vector v(this->size_);
    for (int i = 0; i < this->size_; i++) {
        v[i] = this->arr_[i] + other[i];
    }
    return v;
}
```

**Код из проекта (свободная функция).**

```cpp
Vector operator+(const Vector &vec1, const Vector &vec2) {
    if (vec1.size() != vec2.size()) {
        throw std::length_error("Vectors must be same size");
    }

    Vector v = Vector(vec1.size());
    for (int i = 0; i < vec1.size(); i++) {
        v[i] = vec1[i] + vec2[i];
    }
    return v;
}
```

**Что важно заметить.**

* **Где живёт оператор.** Метод класса объявляется внутри `class` и вызывается у левого операнда (`a.operator+(b)`). Свободная функция объявляется вне класса и принимает оба аргумента явно.
* **Симметрия/преобразования.** Свободная функция симметрична по операндам и не «привязана» к левому; это упрощает неявные преобразования типов для обоих аргументов (если они есть).
* **Инкапсуляция.** Свободная функция в нашем проекте опирается только на публичный интерфейс (`size()`, `operator[]`) без доступа к приватным полям; при необходимости можно использовать `friend`, но здесь это не требуется.
* **Читабельность API.** Оператор `+` остаётся частью внешнего интерфейса модуля (объявление рядом с классом), а класс сохраняет простую, ясную зону ответственности.

**Типичные ошибки.** Делать метод, который меняет левый операнд (оператор `+` должен быть неизменяющим); возвращать ссылку на локальный объект; не проверять размеры перед сложением. Делать метод, который меняет левый операнд (оператор `+` не должен изменять исходники); возвращать ссылку на локальный объект; не проверять размеры.

---

# 7) Правило трёх

**Определение и правила.** Если класс сам управляет ресурсом (память, файл, сокет), обычно нужны три специальных функции: деструктор, конструктор копирования и копирующее присваивание. Вместе они обеспечивают корректное копирование и уничтожение ресурса.

**Код из проекта.**

```cpp
// Деструктор
Vector::~Vector() {
    delete[] this->arr_;
    std::cout << "Delete vector " << this << "
";
}

// Конструктор копирования
Vector::Vector(const Vector &vec) : arr_(new int[vec.size()]), size_(vec.size()) {
    for (int i = 0; i < vec.size(); i++) {
        this->arr_[i] = vec[i];
    }
    std::cout << "Create " << this << " from " << &vec << "
";
}

// Копирующее присваивание
Vector &Vector::operator=(const Vector &vec) {
    if (this == &vec) {
        return *this; // защита от самоприсваивания
    }
    delete[] this->arr_;
    this->size_ = vec.size();
    this->arr_ = new int[vec.size()];
    for (int i = 0; i < vec.size(); i++) {
        this->arr_[i] = vec[i];
    }
    std::cout << "Copy " << &vec << " to " << this << "
";
    return *this;
}
```

**Что важно заметить.** Эти функции работают вместе и поддерживают инварианты класса при копировании и уничтожении объектов.

---

# Вопросы для самопроверки

1. Почему для массивов нужно использовать именно `new[]` и `delete[]`?
2. Какие инварианты держит наш `Vector`? Приведите пример, как их можно случайно нарушить.
3. Чем «глубокая» копия отличается от «поверхностной» и почему нам нужна именно глубокая?
4. Что произойдёт при `v = v;` и как от этого защититься?
5. Зачем нужна `const`‑перегрузка `operator[]`? Почему `size()` помечен `const`?
6. Какие проверки выполняет `operator+` и когда их нужно делать?
